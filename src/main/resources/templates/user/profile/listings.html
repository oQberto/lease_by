<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Listings</title>
    <link rel="shortcut icon" th:href="@{/image/content/logo/logo-title.webp}" type="image/x-icon">
    <link rel="stylesheet" th:href="@{/css/header.css}" type="text/css">
    <link rel="stylesheet" th:href="@{/css/footer.css}" type="text/css">
    <link rel="stylesheet" th:href="@{/css/profile-listings.css}" type="text/css">
    <link rel="stylesheet" th:href="@{/css/searchBox.css}">
</head>
<body>
<div th:insert="~{fragment::header}"></div>

<div class="profile-page">
    <div class="menu" th:insert="~{fragment::menu}"></div>

    <div class="work-zone">
        <div class="listing-nav-bar">
            <span>Listings</span>
            <form th:href="@{#}">
            <button type="submit">Sort by</button>
                <label for="listing">
                    <select id="listing" name="listing">
                        <option th:each="listingStatus: ${listingSatuses}" th:text="${listingStatus}">Status</option>
                    </select>
                </label>
            </form>
        </div>

        <div class="display-zone">
            <p>
                First, we enable an in-memory message broker to carry the messages back to the client on destinations prefixed with “/topic”.

                We complete our simple configuration by designating the “/app” prefix to filter destinations targeting application annotated methods (via @MessageMapping).

                The registerStompEndpoints method registers the “/chat” endpoint, enabling Spring’s STOMP support. Keep in mind that we are also adding an endpoint here that works without the SockJS for the sake of elasticity.

                This endpoint, when prefixed with “/app”, is the endpoint that the ChatController.send() method is mapped to handle.

                It also enables the SockJS fallback options so that alternative messaging options may be used if WebSockets are not available. This is useful since WebSocket is not supported in all browsers yet and may be precluded by restrictive network proxies.
            </p>
            <p>
                Now that we’ve set up the project and configured the WebSocket capabilities, we need to create a message to send.

                The endpoint will accept messages containing the sender name and a text in a STOMP message whose body is a JSON object.

                The message might look like this:
            </p>
        </div>
    </div>
</div>

<div th:insert="~{fragment::footer}"></div>
</body>
</html>